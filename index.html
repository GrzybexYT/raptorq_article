<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RaptorQ: The Black Magic of Liquid Data</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Crimson+Pro:ital,wght@0,200..900;1,200..900&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        @layer base {
            :root {
                --bg: #020204;
                --text-main: #f8fafc;
                --text-muted: #94a3b8;
                --accent-blue: #3b82f6;
                --accent-purple: #a855f7;
                --accent-cyan: #22d3ee;
                --accent-emerald: #10b981;
                --glass-bg: rgba(15, 23, 42, 0.6);
                --glass-border: rgba(255, 255, 255, 0.1);
            }
            body {
                font-family: 'Inter', sans-serif;
                background-color: var(--bg);
                color: var(--text-main);
                font-feature-settings: "cv02", "cv03", "cv04", "cv11", "ss01";
                @apply antialiased selection:bg-cyan-500/40 selection:text-white;
            }
            h1, h2, h3, h4, h5 {
                font-family: 'Bricolage Grotesque', sans-serif;
                @apply tracking-tight leading-none text-white;
            }
            p {
                @apply text-[1.15rem] leading-relaxed text-slate-300 mb-8 font-[400];
            }
            strong {
                @apply text-white font-semibold;
            }
            code {
                font-family: 'JetBrains Mono', monospace;
                @apply text-cyan-400 bg-cyan-950/40 px-1.5 py-0.5 rounded text-[0.85em] font-medium border border-cyan-500/20;
            }
            .math-inline { 
                font-family: 'Crimson Pro', serif; 
                @apply italic text-xl px-1 text-purple-300;
            }
            .link-hover {
                @apply border-b border-slate-700 hover:border-cyan-400 hover:text-cyan-400 transition-colors duration-300;
            }
        }
        @layer components {
            .editorial-container {
                @apply max-w-[840px] mx-auto px-6 lg:px-8 relative z-10;
            }
            .section-divider {
                @apply w-full h-px bg-gradient-to-r from-transparent via-white/10 to-transparent my-32;
            }
            .display-title {
                font-size: clamp(3.5rem, 9vw, 8rem);
                @apply font-extrabold mb-10 text-white leading-[0.85] tracking-tighter;
            }
            .section-title {
                font-size: clamp(2.2rem, 4.5vw, 4rem);
                @apply font-bold mb-14 mt-32 text-white flex items-center gap-5 tracking-tight;
            }
            .section-title::before {
                content: '';
                @apply w-3 h-14 bg-gradient-to-b from-cyan-400 via-blue-500 to-purple-600 rounded-full inline-block;
            }
            .insight-card {
                @apply my-20 p-12 rounded-[2.5rem] border border-white/10 bg-slate-900/40 backdrop-blur-xl relative overflow-hidden transition-all duration-500 hover:border-white/20;
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), inset 0 1px 1px rgba(255,255,255,0.05);
            }
            .insight-card::after {
                content: '';
                @apply absolute inset-0 border border-white/5 rounded-[2.5rem] pointer-events-none;
            }
            .callout {
                @apply border-l-4 border-purple-500/50 pl-8 py-4 my-12 italic text-slate-300 text-2xl font-serif bg-gradient-to-r from-purple-500/10 to-transparent rounded-r-[2rem];
            }
            .viz-container {
                @apply w-full my-24 rounded-[3rem] border border-white/10 bg-[#08080a] relative overflow-hidden min-h-[600px] flex flex-col shadow-[0_0_100px_-20px_rgba(34,211,238,0.1)];
            }
            .viz-header {
                @apply p-8 border-b border-white/5 flex justify-between items-center bg-white/[0.03] backdrop-blur-md;
            }
            .btn-action {
                @apply px-8 py-3.5 bg-cyan-500 text-black font-bold text-xs uppercase tracking-[0.15em] rounded-full hover:bg-cyan-400 hover:scale-105 active:scale-95 transition-all duration-300 shadow-[0_0_25px_rgba(34,211,238,0.3)];
            }
            .btn-secondary {
                @apply px-8 py-3.5 bg-transparent border border-white/20 text-white font-bold text-xs uppercase tracking-[0.15em] rounded-full hover:border-white hover:bg-white/10 transition-all duration-300;
            }
            .sidebar-note {
                @apply text-sm text-slate-500 border-l border-slate-800 pl-4 ml-4 italic my-4 block;
            }
            .floating-glow {
                @apply absolute w-64 h-64 rounded-full blur-[120px] pointer-events-none z-0 opacity-20;
            }
        }
        /* Custom Matrix Animations */
        .matrix-row { transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .row-enter { animation: slideIn 0.5s forwards; }
        .row-solve { animation: flashGreen 1s forwards; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes flashGreen { 0% { background-color: rgba(34, 197, 94, 0.2); } 100% { background-color: transparent; } }
    </style>
</head>
<body>

    <!-- Scroll Progress -->
    <div class="fixed top-0 left-0 h-1.5 w-full bg-gradient-to-r from-cyan-400 via-purple-500 to-blue-500 z-50" id="progress-bar" style="transform: scaleX(0); transform-origin: 0 0; will-change: transform;"></div>

    <!-- Hero Section -->
    <section class="min-h-screen flex flex-col justify-center relative overflow-hidden pb-20">
        <div id="hero-canvas" class="absolute inset-0 z-0"></div>
        <div class="absolute inset-0 bg-gradient-to-b from-transparent via-[#020204]/60 to-[#020204] z-10"></div>
        
        <!-- Ambient Glows -->
        <div class="floating-glow bg-cyan-500 -top-20 -left-20 animate-pulse"></div>
        <div class="floating-glow bg-purple-600 -bottom-20 -right-20 animate-pulse" style="animation-delay: 2s"></div>

        <div class="editorial-container text-center pt-32 relative z-20">
            <div class="inline-flex items-center gap-3 mb-12 px-6 py-2.5 rounded-full border border-white/10 bg-white/5 text-[11px] font-mono text-cyan-400 tracking-[0.3em] uppercase backdrop-blur-xl">
                <span class="w-2 h-2 bg-cyan-400 rounded-full animate-ping"></span>
                Protocol Intelligence / RFC 6330
            </div>
            <h1 class="display-title">
                The Black Magic of<br/>
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-400 to-purple-500 drop-shadow-[0_0_30px_rgba(34,211,238,0.3)]">Liquid Data.</span>
            </h1>
	        <p class="text-2xl md:text-3xl text-slate-400 max-w-3xl mx-auto leading-tight mt-12 font-light">
	                Turning rigid files into a probabilistic stream, defying the laws of data gravity with <span class="text-white font-medium italic">O(1)</span> extra packets.
	        </p>
        </div>
        
        <div class="absolute bottom-16 left-0 w-full flex flex-col items-center gap-4 opacity-50 z-20">
            <span class="text-[10px] uppercase tracking-[0.4em] text-white/40">Scroll to Explore</span>
            <div class="w-px h-16 bg-gradient-to-b from-white/20 to-transparent"></div>
        </div>
    </section>

    <!-- Intro -->
    <article class="editorial-container">
        <p class="drop-cap first-letter:text-9xl first-letter:font-extrabold first-letter:text-transparent first-letter:bg-clip-text first-letter:bg-gradient-to-br first-letter:from-cyan-400 first-letter:to-blue-600 first-letter:float-left first-letter:mr-8 first-letter:mt-[-8px] first-letter:leading-[0.75]">
            Suppose you are trying to stream a 4K video to a Mars rover. The round-trip latency is 40 minutes. Or perhaps you are broadcasting a critical firmware update to a million cars simultaneously over a patchy cellular network.
        </p>
        <p>
            The traditional way we move data—TCP—is fundamentally a conversation. "I sent packet 4." "I didn't get packet 4." "Okay, resending packet 4." "Okay, got it." This conversational model works fine for loading a webpage, but it falls apart at scale or extreme latency. It requires a feedback loop. It requires the sender to know exactly what the receiver is missing.
        </p>
        <p>
            But imagine a different world. Imagine you don't care about "Packet #4." Imagine you could turn your file into a <strong class="text-cyan-300 shadow-cyan-500/20 drop-shadow-sm">mathematical liquid</strong>. You open the valve and spray packets at the receiver. The receiver is just a bucket. It doesn't matter <em>which</em> drops of liquid land in the bucket. It doesn't matter if half the spray blows away in the wind.
        </p>
	        <p>
	            As soon as the bucket is full—roughly \(K+\epsilon\) drops (a tiny overhead), not a particular set—the receiver reconstructs the data.
	        </p>
        
        <div class="insight-card group">
            <div class="absolute -right-10 -top-10 opacity-5 group-hover:opacity-10 transition-opacity duration-1000 rotate-12 scale-150">
                <svg width="400" height="400" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
            </div>
            <div class="relative z-10">
	            <h3 class="text-3xl font-bold text-white mb-6">The Impossible Promise</h3>
	            <p class="text-slate-400 text-lg mb-0 leading-relaxed">
	                This isn't sci-fi. It's <strong>RaptorQ (RFC 6330)</strong>. The RFC has a SHALL-level decoder requirement: if you receive encoding symbols whose IDs are chosen uniformly at random, the <em>average</em> decode failure rate must be at most 1/100 when receiving \(K'\) symbols, 1/10,000 at \(K'+1\), and 1/1,000,000 at \(K'+2\).<br/><br/>
	                At \(K \approx 10{,}000\), two extra symbols is about <span class="text-cyan-400 font-mono font-bold">0.02%</span> overhead.
	            </p>
            </div>
	        </div>
    </article>

    <div class="section-divider"></div>

    <!-- Section 0.5: PAR Files Bridge -->
    <section class="editorial-container">
        <h2 class="section-title">What You May Already Know</h2>
        <p>
            If you've ever used <strong>PAR2 files</strong> to repair a corrupted download, or relied on RAID 5 to survive a dead drive, you've already seen the seed of this idea. PAR2 uses Reed-Solomon codes to generate repair blocks from your original data. Lose a few files? Throw in some <code>.par2</code> recovery blocks, and the repair tool reconstructs the missing pieces. Any recovery block helps—you don't need specific ones.
        </p>
        <p>
            Reed-Solomon is powerful. It achieves what coding theorists call <strong>MDS</strong> (Maximum Distance Separable) behavior: any \(K\) of \(K+R\) encoded symbols perfectly reconstruct \(K\) source symbols. Zero overhead. Mathematically optimal.
        </p>
        <p>
            So why isn't this the end of the story? Two problems:
        </p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-10 mt-12 mb-16">
            <div class="bg-slate-900/60 backdrop-blur-xl border border-white/10 rounded-[2rem] p-10 transition-all duration-500 hover:border-cyan-500/30 group">
                <h4 class="text-white font-bold mb-5 text-xl group-hover:text-cyan-400 transition-colors">You must choose \(R\) in advance</h4>
                <p class="text-sm text-slate-400 leading-relaxed mb-0 font-light">
                    Reed-Solomon is <strong>fixed-rate</strong>. You pick your redundancy budget before you send anything. If the channel is worse than expected, you're dead. If it's better, you wasted bandwidth. For a satellite broadcasting to a million receivers—each with different loss rates—there is no single right \(R\).
                </p>
            </div>
            <div class="bg-slate-900/60 backdrop-blur-xl border border-white/10 rounded-[2rem] p-10 transition-all duration-500 hover:border-purple-500/30 group">
                <h4 class="text-white font-bold mb-5 text-xl group-hover:text-purple-400 transition-colors">It gets slow at scale</h4>
                <p class="text-sm text-slate-400 leading-relaxed mb-0 font-light">
                    Reed-Solomon encoding and decoding cost grows with block size. Standard implementations are \(O(n \cdot K)\) for encoding and \(O(K^2)\) for decoding. For \(K = 50{,}000\) (a 50 MB file with 1 KB symbols), that's 2.5 billion operations just to decode. Fast, but not "stream 4K video" fast.
                </p>
            </div>
        </div>
        <p>
            The <strong>fountain code</strong> dream, articulated by Byers, Luby, and Mitzenmacher in the late 1990s, was to fix both problems at once: don't choose a rate. Don't negotiate. Just open a valve and spray encoded packets. Each receiver collects whichever drops happen to arrive and stops when it has enough. Late joiners aren't penalized. Lossy links just take longer.
        </p>
        <p>
            Reed-Solomon gave us the "any \(K\) of \(N\)" property. Fountain codes ask: what if \(N\) could be <em>infinity</em>?
        </p>
    </section>

    <div class="section-divider"></div>

    <!-- Section 1: Linear Algebra -->
    <section class="editorial-container">
        <h2 class="section-title">Packets Are Equations</h2>
        <p>
            To understand why this isn't magic, we have to stop looking at packets as "chunks of a file" and start looking at them as <strong>Linear Equations</strong>.
        </p>
        <p>
            In a standard file transfer, if I send you the first 1KB block of a file, I am sending you the equation:
            <br/><span class="block text-center my-10 font-mono text-cyan-400 text-2xl bg-white/[0.03] py-8 rounded-[2rem] border border-white/10 backdrop-blur-xl shadow-2xl">1·x₁ + 0·x₂ + ... + 0·xₖ = Packet₁</span>
        </p>
        <p>
            In RaptorQ, we treat the source data as a vector of unknowns \([x_1, x_2, ..., x_K]\). We generate an infinite stream of encoded packets. Each packet is the XOR sum of a random subset of the source symbols.
        </p>

        <!-- Interactive XOR Matrix Viz -->
        <div class="viz-container" id="viz-matrix">
            <div class="viz-header">
                <div class="flex items-center gap-4">
                    <div class="w-10 h-10 rounded-2xl bg-cyan-500/20 flex items-center justify-center">
                        <svg class="w-6 h-6 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                    </div>
                    <div>
                        <h4 class="font-bold text-white text-sm uppercase tracking-widest">Interactive 01</h4>
                        <div class="text-[10px] text-slate-500 uppercase tracking-[0.2em] font-mono">The Matrix View</div>
                    </div>
                </div>
                <div class="flex gap-4">
                    <button onclick="matrixViz.step()" class="btn-action">Add Equation</button>
                    <button onclick="matrixViz.reset()" class="btn-secondary">Reset</button>
                </div>
            </div>
            <div class="flex-1 p-10 grid grid-cols-1 lg:grid-cols-2 gap-16 items-center">
                <div id="matrix-render-area" class="font-mono text-sm leading-relaxed overflow-visible min-h-[300px]"></div>
                <div class="space-y-8">
                    <div>
                        <div class="text-[10px] text-slate-500 uppercase tracking-[0.3em] font-bold mb-3">System Solvability</div>
                        <div id="rank-status" class="text-6xl font-bold text-slate-800 transition-all duration-700 tracking-tighter">Rank: 0 / 4</div>
                    </div>
	                <p class="text-slate-400 text-base leading-relaxed font-light">
	                    We are solving \(Ax = b\) over GF(2). In this field, addition is XOR. In the real RFC 6330 scheme, most work stays XOR-cheap, but a small "insurance" component uses GF(256) to improve rank.
	                </p>
                    <div class="bg-gradient-to-br from-blue-500/10 to-purple-500/10 p-8 rounded-[2rem] border border-white/10 text-sm text-blue-200/80 backdrop-blur-xl relative overflow-hidden group">
                        <div class="absolute -right-4 -bottom-4 w-24 h-24 bg-blue-500/20 rounded-full blur-3xl group-hover:bg-blue-500/30 transition-all duration-500"></div>
                        <strong class="block mb-2 text-blue-300 text-lg">Rank-Nullity Theorem</strong>
                        Every new <em>linearly independent</em> packet reduces the uncertainty of the system. When Rank equals \(K\), the solution space collapses to a single point: your file.
                    </div>
                </div>
            </div>
        </div>

	        <p>
	            This explains the <strong>fungibility</strong>. Order doesn't matter because the order in which you write down equations doesn't change the solution. Every new packet provides a bit more information, constraining the possible values of the source symbols.
	        </p>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Interlude: The Three Promises -->
	    <section class="editorial-container">
	        <h2 class="section-title">What RaptorQ Promises</h2>
	        <p>
	            If you compress RFC 6330 into three adjectives, you get: <strong>rateless</strong>, <strong>systematic</strong>, and <strong>near-MDS</strong>.
	        </p>
	        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-10">
	            <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-3 text-lg">Rateless</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    The sender can generate as many repair packets as needed. If the receiver is on a noisy link, it just keeps collecting. If the link is clean, it stops early. No fixed \(n\). No negotiation loop.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-3 text-lg">Systematic</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    The original data symbols are part of the encoding stream. In the common case of low loss, the receiver just gets the source symbols and never runs a decoder.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-3 text-lg">Near-MDS</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    It behaves almost like an optimal erasure code: you need only slightly more than the block size. The RFC even pins down a steep reliability curve (for \(K'\), the padded block size): \(\le 1\%\) failure at \(K'\), \(\le 0.01\%\) at \(K'+1\), \(\le 10^{-6}\) at \(K'+2\).
	                </p>
	            </div>
	        </div>
	        <p class="text-slate-400 text-sm leading-relaxed mt-10">
	            The important nuance: it is not saying <em>every</em> adversarially-chosen set of \(K\) packets works. It says <em>almost any</em> set of \(K\) or \(K+\epsilon\) packets works when packets are generated according to the standard's deterministic randomness.
	        </p>
	    </section>

	    <!-- Section 2: The Logarithm Tax -->
	    <section class="editorial-container">
	        <h2 class="section-title">The Coupon Collector's Tax</h2>
        <p>
            If the idea is just "send random linear equations," why didn't we do this 50 years ago? It's called <strong>Random Linear Network Coding</strong>, and it works perfectly. But there is a catch.
        </p>
        <p>
            Solving a dense system of \(K\) linear equations takes \(O(K^3)\) time (Gaussian Elimination). If your file has 50,000 blocks, \(50,000^3\) is 125 trillion operations. Your CPU would melt before the video started playing.
        </p>
        <p>
            So, we optimize. We make the equations <strong>sparse</strong>. Instead of XORing 50% of the symbols, we XOR only a few (say, 5 or 10). This makes solving fast. But it introduces a new villain: the <strong>Coupon Collector Problem</strong>.
        </p>
        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 my-12">
            <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-3">A Subtle Failure Mode</div>
            <p class="text-slate-400 text-sm mb-4 leading-relaxed">
                Sparsity doesn't just create a coverage problem. It can also create <strong>rank deficiency</strong>: you can receive \(K\) sparse equations and still not be able to solve, because they're accidentally dependent.
            </p>
            <div class="font-mono text-sm text-slate-300 leading-relaxed">
                e₁ = A ⊕ B &nbsp;&nbsp;[1,1,0,0]<br/>
                e₂ = C ⊕ D &nbsp;&nbsp;[0,0,1,1]<br/>
                e₃ = A ⊕ C &nbsp;&nbsp;[1,0,1,0]<br/>
                e₄ = B ⊕ D &nbsp;&nbsp;[0,1,0,1]<br/>
                <span class="text-slate-500">Row1 ⊕ Row2 ⊕ Row3 ⊕ Row4 = 0 → dependent.</span>
            </div>
        </div>
        <div class="callout">
            With constant-degree random mixing, you need \(O(K \log K)\) packets to cover every symbol with high probability.
        </div>

        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 my-12">
            <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-4">The Probability You Should Tattoo On Your Intuition</div>
            <p class="text-slate-300 text-sm leading-relaxed mb-4">
                Suppose each encoded packet touches exactly \(d\) randomly chosen source symbols. After receiving \(n\) packets, you've made about \(d \cdot n\) random "touches" across \(K\) symbols. Pick one specific symbol \(x_i\). The probability it was <em>never</em> touched is:
            </p>
            <div class="text-center my-6 font-mono text-cyan-400 text-lg bg-white/5 py-4 rounded-xl border border-white/5">
                \(P(x_i \text{ untouched}) \approx \left(1 - \frac{1}{K}\right)^{dn} \approx e^{-dn/K}\)
            </div>
            <p class="text-slate-300 text-sm leading-relaxed mb-4">
                If you aim for \(n \approx K\) (tiny overhead), that becomes \(\approx e^{-d}\), a <em>constant</em>—it doesn't go to zero.
            </p>
            <p class="text-slate-300 text-sm leading-relaxed mb-0">
                With \(d = 5\), you should expect about \(e^{-5} \approx 0.7\%\) of your symbols to have <strong>zero appearances</strong>. That's ~70 symbols in a block of 10,000 that are <em>information-theoretically unrecoverable</em>—no algorithm on Earth can recover what was never constrained. To drive the expected untouched count below 1, you need \(d \gtrsim \ln K\). That's the log tax.
            </p>
        </div>

	        <p>
	            That \(\log K\) factor is a tax. In the simplest coupon-collector baseline (each packet reveals one uniformly random symbol), the expected draws to see all \(K\) coupons is
	            \(K \cdot H_K \approx K(\ln K + \gamma)\). For \(K=10{,}000\), that's about \(97{,}900\) singletons. If each packet mixes a constant number of symbols, you improve the constant, but the \(\log K\) tail remains.
	            We want something that behaves like \(K + O(1)\), not \(K \log K\).
	        </p>
	        <p>
	            This seemed like a fundamental law of nature: you can have <strong>Speed</strong> (sparse) or you can have <strong>Efficiency</strong> (dense), but not both.
	        </p>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 2.5: LT Codes -->
	    <section class="editorial-container">
	        <h2 class="section-title">LT Codes: The Ripple</h2>
	        <p>
	            LT codes (Luby, 2002) were the first practical fountain codes, and their core move is surprisingly simple: <strong>don't pick a fixed degree</strong>.
	            For each packet, you choose a degree \(d\) (how many symbols to XOR together) from a carefully shaped distribution, then XOR those \(d\) symbols.
	        </p>

		        <div class="insight-card">
		            <h3 class="text-2xl font-bold text-white mb-6">The Soliton Intuition</h3>
		            <p class="text-slate-300">
		                A degree-\(d\) equation becomes <em>useful</em> when exactly \(d-1\) of its neighbors are already known, because then it collapses to a single unknown.
		                If roughly \(K/d\) symbols remain unknown late in decoding, degree-\(d\) packets are the ones that are "about to release".
		            </p>
		            <p class="text-slate-400 text-sm leading-relaxed mb-6">
		                The idealized version of this idea is the <strong>Ideal Soliton</strong> degree law:
		            </p>
		            <div class="bg-black/50 border border-white/5 rounded-2xl p-6 font-mono text-sm text-slate-300 leading-relaxed overflow-x-auto">
		                \(\rho(1) = 1/K\)<br/>
		                \(\rho(d) = 1/(d(d-1))\) &nbsp;&nbsp;for \(d = 2,3,\dots,K\)
		            </div>
		            <p class="text-slate-400 text-sm leading-relaxed mt-6 mb-0">
		                In practice the ideal soliton is too fragile (variance kills the cascade), so LT codes use a <strong>Robust Soliton</strong> distribution: it adds a buffer so the decoder has a steady supply of easy degree-1 packets.
		            </p>
		        </div>

		        <div class="viz-container" id="viz-degree-ripple">
		            <div class="viz-header">
		                <h4 class="font-bold text-white uppercase tracking-widest text-xs flex items-center gap-2">
		                    <span class="w-2 h-2 bg-purple-400 rounded-full"></span>
		                    Interactive 02: Degrees &amp; Ripple
		                </h4>
		                <div class="flex gap-2">
		                    <button onclick="degreeRippleViz.simulate()" class="btn-action">Simulate</button>
		                    <button onclick="degreeRippleViz.resample()" class="btn-secondary">Resample</button>
		                </div>
		            </div>
		            <div class="p-6 border-b border-white/5 bg-white/[0.01]">
		                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
		                    <div>
		                        <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-2">Distribution</div>
		                        <select id="degree-ripple-dist" onchange="degreeRippleViz.setDist(this.value)" class="w-full bg-black/40 border border-white/10 rounded-xl px-4 py-3 text-sm text-slate-200 focus:outline-none focus:ring-2 focus:ring-cyan-500/30">
		                            <option value="rfc6330">RFC 6330 Degree Table (RaptorQ)</option>
		                            <option value="robust">Robust Soliton (LT)</option>
		                            <option value="ideal">Ideal Soliton</option>
		                        </select>
		                    </div>
		                    <div class="grid grid-cols-1 gap-4">
		                        <div>
		                            <div class="flex justify-between items-center mb-2">
		                                <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500">K (variables)</div>
		                                <div id="degree-ripple-k-label" class="text-[10px] font-mono text-slate-400"></div>
		                            </div>
		                            <input id="degree-ripple-k" type="range" min="200" max="2000" step="100" value="800" oninput="degreeRippleViz.setK(parseInt(this.value,10))" class="w-full accent-cyan-400">
		                        </div>
		                        <div>
		                            <div class="flex justify-between items-center mb-2">
		                                <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500">Overhead</div>
		                                <div id="degree-ripple-overhead-label" class="text-[10px] font-mono text-slate-400"></div>
		                            </div>
		                            <input id="degree-ripple-overhead" type="range" min="0" max="20" step="1" value="5" oninput="degreeRippleViz.setOverhead(parseInt(this.value,10))" class="w-full accent-purple-400">
		                        </div>
		                        <div>
		                            <div class="flex justify-between items-center mb-2">
		                                <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500">Robust c</div>
		                                <div id="degree-ripple-c-label" class="text-[10px] font-mono text-slate-400"></div>
		                            </div>
		                            <input id="degree-ripple-c" type="range" min="2" max="10" step="1" value="5" oninput="degreeRippleViz.setC(parseInt(this.value,10))" class="w-full accent-emerald-400">
		                        </div>
		                    </div>
		                </div>
		            </div>
		            <div class="p-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
		                <div class="bg-black/40 border border-white/5 rounded-2xl p-4">
		                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-3">Degree Distribution</div>
		                    <div id="degree-ripple-bar" class="h-[260px]"></div>
		                </div>
		                <div class="bg-black/40 border border-white/5 rounded-2xl p-4">
		                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-3">Ripple During Peeling</div>
		                    <div id="degree-ripple-line" class="h-[260px]"></div>
		                </div>
		            </div>
		            <div class="p-6 border-t border-white/5 text-sm text-slate-500 text-center">
		                <span id="degree-ripple-stats"></span>
		            </div>
		        </div>

		        <p>
		            The decoding picture is graph-theoretic. Draw a bipartite graph: variables on the left (unknown symbols), checks on the right (received packets), and edges for "this packet touches that symbol".
		            The <strong>ripple</strong> is the set of degree-1 check nodes at any moment.
		        </p>
	        <p>
	            Peeling succeeds as long as the ripple never hits zero. If it does, you're in a <strong>stopping set</strong> (a <strong>2-core</strong>): every remaining packet has degree \(\ge 2\), so nothing is directly solvable.
	        </p>
	        <p>
	            LT codes make this work often, but the final stretch is still expensive: to drive the failure probability very low using <em>only</em> peeling, you pay a growing overhead term.
	            In classic analyses of robust-soliton LT codes, the number of received symbols looks like \(K + O(\sqrt{K}\log^2(K/\delta))\) to achieve failure probability \(\delta\): a vanishing fraction as \(K\) grows, but not a constant-number-of-packets guarantee.
	            That's the tail Raptor codes eliminate.
	        </p>
	    </section>

	    <!-- Section 3: The Wildly Clever Idea -->
	    <section class="editorial-container">
	        <h2 class="section-title">The "Aha!" Moment</h2>
        <p>
            This is where <strong>RaptorQ</strong> pulls its "black magic" trick. The insight is so simple it's almost embarrassing:
        </p>
        <p class="text-3xl font-bold text-center text-white my-16 leading-tight">
            Don't try to make the fountain code perfect.<br/>
            <span class="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400">Make it sloppy, then clean up the mess.</span>
        </p>
        <p>
            Instead of trying to recover 100% of the symbols using the sparse fountain code (which incurs an expensive tail), we only ask the fountain code to recover <strong>97%</strong> of the symbols.
        </p>
        <p>
            Getting to 97% is easy. It costs \(O(K)\). The curve is steep at the beginning. It's only the "tail"—the last few stubborn symbols—that is expensive. So we simply truncate the tail.
        </p>
	        <p>
	            But wait, we need 100% of the file. So, <em>before</em> we start the fountain process, we take our source file and apply a <strong>Precode</strong>. We expand the file by a tiny amount (say, 3%) using a high-density erasure code.
	        </p>
	        <p>
	            In RaptorQ, that precode is layered: a sparse LDPC-style part (cheap XOR constraints) plus a small, denser HDPC "insurance" part (where the spec leans on GF(256) to crush rank failures).
	        </p>

        <div class="viz-container" id="viz-precode">
            <div class="viz-header">
                <h4 class="font-bold text-white uppercase tracking-widest text-xs flex items-center gap-2">
                    <span class="w-2 h-2 bg-purple-400 rounded-full"></span>
                    Interactive 03: The Precode Repair
                </h4>
            </div>
            <div class="flex-1 relative p-8 bg-gradient-to-b from-[#0a0a0c] to-[#050507]">
                <!-- SVG Visualization of Precode -->
                <svg id="precode-svg" width="100%" height="400" viewBox="0 0 800 400" class="overflow-visible"></svg>
                <div class="absolute bottom-6 right-6 flex gap-2">
                     <button onclick="precodeViz.animate()" class="btn-action">Run Simulation</button>
                </div>
            </div>
        </div>

        <p>
            The workflow becomes a two-stage rocket:
        </p>
        <ol class="list-decimal list-inside space-y-4 text-slate-300 ml-4 mb-12 border-l border-white/10 pl-6">
            <li><strong>The Precode (Insurance):</strong> Expand source \(K\) to Intermediate \(L\) (adding ~3% structured redundancy).</li>
            <li><strong>The Fountain (Delivery):</strong> Spray packets generated from \(L\) using a fast, sparse code (LT Code).</li>
            <li><strong>Decoding Phase 1:</strong> The receiver collects packets and uses the fast sparse decoder. It stalls at roughly 97%.</li>
            <li><strong>Decoding Phase 2:</strong> The Precode kicks in. Because the Intermediate file has internal structure, we can mathematically deduce the missing 3% from the 97% we found.</li>
        </ol>
	        <p>
	            We moved the "hard work" from the probabilistic layer (where it costs overhead) to a deterministic layer (where it is cheap because the missing count is small).
	        </p>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 3.5: Intermediate Symbols -->
		    <section class="editorial-container">
		        <h2 class="section-title">What's Actually Being Solved</h2>
		        <p>
		            One detail that's easy to miss: RaptorQ doesn't directly solve for your raw source symbols.
	            It first defines a slightly larger set of <strong>intermediate symbols</strong> \(C[0],\dots,C[L-1]\), then constructs equations that let the decoder recover those \(L\) unknowns.
	        </p>
	        <p>
	            Very roughly, the standard builds a system with:
	        </p>
	        <ul class="list-disc list-inside space-y-2 text-slate-300 ml-4 mb-10">
	            <li><strong>LT constraints (sparse):</strong> the fountain layer equations (peel-friendly).</li>
	            <li><strong>LDPC constraints (sparse):</strong> a web of cheap "insurance" equations.</li>
	            <li><strong>HDPC constraints (denser):</strong> a small set of heavy-hitting equations where GF(256) improves rank.</li>
	        </ul>
		        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 overflow-x-auto">
		            <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-4">A Mental Model (Not Exact RFC Layout)</div>
		            <pre class="font-mono text-sm text-slate-300 leading-relaxed mb-0">+------------------------------------+
| HDPC constraints (H rows, GF(256))  |
| LDPC constraints (S rows, GF(2))    |
| LT   constraints (≈K rows, GF(2))   |
+------------------------------------+
                L unknowns</pre>
		        </div>
		        <p class="text-slate-400 text-sm leading-relaxed mt-8">
		            Most operations stay XOR-cheap (GF(2)). The GF(256) part is deliberately isolated: it costs more per operation, but it buys you a dramatic reduction in "unlucky" rank deficiency.
		        </p>
		    </section>

		    <div class="section-divider"></div>

		    <!-- Section 3.6: Toy Walkthrough -->
		    <section class="editorial-container">
		        <h2 class="section-title">Walkthrough: A Toy Decode</h2>
		        <p>
		            Let's do a complete end-to-end decode in miniature. We'll use \(K=4\) one-byte source symbols \(A,B,C,D\), plus one precode parity symbol \(P\).
		            The receiver will <em>never</em> receive \(C\) directly, yet will still reconstruct it.
		        </p>
		        <p class="sidebar-note">
		            This is not the exact RFC 6330 matrix layout. It's the same algebra (XOR over GF(2)) with small numbers so you can see every step.
		        </p>

		        <div class="viz-container" id="viz-toy-decode">
		            <div class="viz-header">
		                <h4 class="font-bold text-white uppercase tracking-widest text-xs flex items-center gap-2">
		                    <span class="w-2 h-2 bg-cyan-400 rounded-full"></span>
		                    Interactive 04: End-to-End Toy Decode
		                </h4>
		                <div class="flex gap-2">
		                    <button onclick="toyDecodeViz.prev()" class="btn-secondary">Back</button>
		                    <button onclick="toyDecodeViz.next()" class="btn-action">Next</button>
		                    <button onclick="toyDecodeViz.reset()" class="btn-secondary">Reset</button>
		                    <button onclick="toyDecodeViz.auto()" class="btn-action">Auto</button>
		                </div>
		            </div>
		            <div class="p-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
		                <div class="lg:col-span-2 bg-black/40 border border-white/5 rounded-2xl p-4">
		                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-2">Step</div>
		                    <div id="toy-decode-step" class="text-slate-200 text-sm leading-relaxed"></div>
		                </div>
		                <div class="bg-black/40 border border-white/5 rounded-2xl p-4">
		                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-2">Symbols</div>
		                    <div id="toy-decode-symbols" class="font-mono text-sm text-slate-200"></div>
		                </div>
		                <div class="bg-black/40 border border-white/5 rounded-2xl p-4">
		                    <div class="text-[10px] uppercase tracking-widest font-bold text-slate-500 mb-2">Equations</div>
		                    <div id="toy-decode-equations" class="font-mono text-sm text-slate-200"></div>
		                </div>
		            </div>
		            <div class="p-6 border-t border-white/5 text-sm text-slate-500 text-center">
		                <span id="toy-decode-status"></span>
		            </div>
		        </div>
		    </section>

		    <!-- Section 4: Inactivation Decoding -->
		    <section class="editorial-container">
		        <h2 class="section-title">Peeling & Inactivation</h2>
        <p>
            We've solved the overhead problem. Now, how do we solve the speed problem? How do we solve 50,000 equations in milliseconds?
        </p>
        <p>
            We use a <strong>Peeling Decoder</strong> (also known as Belief Propagation). It works like Sudoku.
        </p>
        <p>
            You look for an equation with only <strong>one unknown</strong>. You solve it instantly. Then you "peel" that known value out of all other equations (by XORing it into them). This might reduce a complex equation to a single-unknown equation. You solve that one. The process cascades.
        </p>
        
        <div class="viz-container" id="viz-peeling">
            <div class="viz-header">
                <h4 class="font-bold text-white uppercase tracking-widest text-xs flex items-center gap-2">
                    <span class="w-2 h-2 bg-emerald-400 rounded-full"></span>
                    Interactive 05: The Peeling Cascade
                </h4>
                <div class="flex gap-2">
                     <button onclick="peelingViz.step()" class="btn-action">Peel Step</button>
                     <button onclick="peelingViz.reset()" class="btn-secondary">Reset</button>
                </div>
            </div>
            <div id="peeling-canvas" class="flex-1 w-full h-[400px]"></div>
            <div class="p-6 border-t border-white/5 text-center text-sm text-slate-500">
                Click "Peel Step" to find degree-1 packets (yellow) and resolve their source blocks (green).
            </div>
        </div>

        <p>
            But what if the peeling stalls? What if every remaining equation depends on at least 2 unknowns?
        </p>
	        <p>
	            This is where RaptorQ introduces <strong>Inactivation Decoding</strong>. Instead of giving up, the algorithm picks a variable, marks it as "Inactive" (essentially saying, "I'll deal with you later"), and moves it to a separate list. This breaks the deadlock and lets peeling continue.
	        </p>
		        <p>
		            At the end, you are left with a tiny "core" of Inactive variables. You solve this small core using expensive Gaussian Elimination. Because the core is tiny (thanks to the Precode), the cubic cost is confined to a small \(p \times p\) solve, not a full \(K \times K\) one.
		        </p>
	        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 my-12">
	            <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-4">Inactivation Decoding In 4 Phases</div>
	            <ol class="list-decimal list-inside space-y-3 text-slate-300 ml-2 text-sm leading-relaxed mb-0">
	                <li><strong>Triangulate (Peel):</strong> greedily eliminate degree-1 checks; this solves the easy majority in linear time.</li>
	                <li><strong>Inactivate:</strong> when the ripple dies (2-core), pick a variable to "park" as unknown and keep peeling around it.</li>
	                <li><strong>Dense solve:</strong> run Gaussian elimination on the inactive core only (this is where the GF(256) insurance matters).</li>
	                <li><strong>Back-substitute:</strong> push the solved core back into the sparse system and finish peeling.</li>
	            </ol>
	        </div>
		    </section>

	    <div class="section-divider"></div>

	    <!-- Section 5: The Engineering Tricks -->
	    <section class="editorial-container">
	        <h2 class="section-title">The Engineering Tricks</h2>
	        <p>
	            The story so far is clean: sparse equations for speed, a precode for the tail, inactivation for stalls. The reason it works in production is the <em>engineering</em> around those ideas.
	        </p>
	        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-12">
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Systematic Encoding</h4>
	                <p class="text-sm text-slate-400 leading-relaxed">
	                    The first \(K\) encoding symbols are the source symbols themselves: \(y_i = x_i\) for \(0 \le i &lt; K\). If the channel is clean, the receiver doesn't decode at all. Repair symbols are only sent when reality demands them.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">One Integer of Metadata</h4>
	                <p class="text-sm text-slate-400 leading-relaxed">
	                    A repair packet doesn't carry a big coefficient vector. It carries an <strong>Encoding Symbol ID</strong> (ESI). Sender and receiver run the same deterministic generator (which internally maps ESI → ISI) to reconstruct <em>which</em> intermediate symbols were combined. Broadcast-friendly, coordination-free.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Padding to \(K'\) (Systematic Indices)</h4>
	                <p class="text-sm text-slate-400 leading-relaxed">
	                    RFC 6330 quietly pads your block from \(K\) to \(K'\) using a lookup table (Table 2): it adds \(K' - K\) <em>padding symbols</em> that are never transmitted.
	                    This lets encoder and decoder reuse fixed parameters (like \(S,H,W,P\), with several chosen as primes) and keeps behavior interoperable across implementations.
	                    It also explains why transport uses ESI, while the internal algebra uses ISI (repair ISIs are shifted by \(K' - K\)).
	                </p>
	            </div>
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">A Degree Table, Not Pure Randomness</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    RFC 6330 hardcodes a degree distribution (implemented as a threshold table on a small PRNG value) heavily weighted toward low degrees (2 and 3 dominate). The expected LT degree is about <strong>4.8</strong>. With permanently-inactivated symbols, each repair symbol touches about <strong>7</strong> intermediates on average: constant work per packet.
		                </p>
		            </div>
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">Permanent Inactivation</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    Peeling works until it doesn't. RaptorQ makes the dense core predictable by pre-selecting a small set of intermediate symbols (the PI symbols) to be treated as inactivated from the start, so the remaining sparse system peels cleanly. It's a controlled expense: a tiny cubic solve to avoid a catastrophic stall.
		                </p>
		            </div>
		        </div>
		        <p class="mt-12">
		            The key to making this interoperable is that "randomness" is <em>deterministic</em>. A repair packet carries an integer ID (the <strong>ESI</strong> / Encoding Symbol ID). Both sender and receiver run the same tuple generator keyed by that ID (and the derived internal ISI) to reconstruct the packet's neighbor pattern.
		        </p>
		        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 my-10 overflow-x-auto">
		            <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-4">How One ID Becomes An Equation (Simplified)</div>
		            <pre class="font-mono text-sm text-slate-300 leading-relaxed mb-0">id  = ESI
isi = id (source), or id + (K' - K) (repair)   // skips padding ISIs
d   = degree_from_table(isi)   // mostly 2,3,4...
b,a = tuple_params(isi)        // stepping params

indices = []
for t in 0..d-1:
  indices.push(b)
  b = (b + a) mod L

y = XOR(C[i] for i in indices) // most coefficients are 0/1 in practice</pre>
		        </div>
		        <p class="text-slate-400 text-sm leading-relaxed">
		            In the actual RFC, the tuple generator also selects a small number of "PI" (permanently inactivated) neighbors in a separate range, specifically to control the dense core. The core idea is the same: an ID deterministically expands into a sparse neighbor set.
		        </p>
		        <p class="text-slate-400 text-sm leading-relaxed">
		            The point isn't the exact constants; it's the shape: the <em>header</em> stays tiny (an ID), while the receiver still knows the exact linear equation each packet represents.
		        </p>
		    </section>

		    <div class="section-divider"></div>

	    <!-- Section 5.5: Why +2 Changes Everything -->
	    <section class="editorial-container">
	        <h2 class="section-title">Why +2 Packets Changes Everything</h2>
	        <p>
	            The RFC 6330 failure rates look almost too good to be true: \(\le 1\%\) at \(K'\), \(\le 0.01\%\) at \(K'+1\), \(\le 10^{-6}\) at \(K'+2\). Two extra packets improve reliability by four orders of magnitude? That demands an explanation.
	        </p>

	        <h3 class="text-xl font-bold text-white mt-12 mb-6">Two Different Overheads</h3>
	        <p>
	            First, let's untangle two things that often get conflated:
	        </p>
	        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-8 mb-12">
	            <div class="bg-black/50 border border-white/5 rounded-2xl p-6">
	                <h4 class="text-white font-bold mb-3">Channel loss overhead</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    If the link drops packets with probability \(p\), you must send roughly \(1/(1-p)\) times as many packets so that \(K\) arrive. This is a transport-layer concern. With 10% loss, you send ~\(1.11K\). This is the cost of the channel, not the code.
	                </p>
	            </div>
	            <div class="bg-black/50 border border-white/5 rounded-2xl p-6">
	                <h4 class="text-white font-bold mb-3">Code inefficiency overhead</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    How many <em>extra</em> symbols beyond \(K\) must the receiver collect because the code isn't a perfect MDS fountain? For RaptorQ, this is typically 0, 1, or 2 symbols—not a percentage of \(K\). That's the jaw-drop.
	                </p>
	            </div>
	        </div>
	        <p>
	            RaptorQ's reputation for "tiny overhead" is about the second number. The code's intrinsic inefficiency is essentially <strong>constant</strong>—a handful of extra symbols, independent of \(K\).
	        </p>

	        <h3 class="text-xl font-bold text-white mt-16 mb-6">Random Rank Is Your Friend</h3>
	        <p>
	            Here's the clean piece of math that demystifies the dramatic drop. If you pick a random \(K \times K\) matrix over GF(\(q\)), the probability it's full rank is:
	        </p>
	        <div class="text-center my-8 font-mono text-cyan-400 text-lg bg-white/5 py-4 rounded-xl border border-white/5">
	            \(P(\text{full rank}) = \prod_{j=1}^{K} \left(1 - q^{-j}\right)\)
	        </div>
	        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-10">
	            <div class="bg-red-500/5 border border-red-500/10 rounded-2xl p-6">
	                <h4 class="text-red-300 font-bold mb-3">Over GF(2) <span class="text-xs font-mono text-red-400">(pure XOR)</span></h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-2">
	                    The product converges to about <strong class="text-red-300">0.289</strong>. That's a ~71% chance of failure with exactly \(K\) random binary equations. Each extra row helps, but failure drops by a factor of only \(\sim 1/2\) per additional equation.
	                </p>
	                <p class="text-xs text-slate-500 mb-0">
	                    \(K\) rows: ~29% success &nbsp;·&nbsp; \(K+1\): ~57% &nbsp;·&nbsp; \(K+2\): ~78%
	                </p>
	            </div>
	            <div class="bg-emerald-500/5 border border-emerald-500/10 rounded-2xl p-6">
	                <h4 class="text-emerald-300 font-bold mb-3">Over GF(256) <span class="text-xs font-mono text-emerald-400">(byte arithmetic)</span></h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-2">
	                    The product converges to about <strong class="text-emerald-300">0.996</strong>. Nearly full rank with exactly \(K\) rows. And each extra row crushes failure probability by a factor of \(\sim 1/256\).
	                </p>
	                <p class="text-xs text-slate-500 mb-0">
	                    \(K\) rows: ~99.6% &nbsp;·&nbsp; \(K+1\): ~99.998% &nbsp;·&nbsp; \(K+2\): ~99.99999%
	                </p>
	            </div>
	        </div>
	        <p>
	            This is why RaptorQ uses GF(256) for its dense HDPC "insurance" component: the larger field makes random coefficient vectors dramatically more independent. Over GF(2), there are only \(2^K\) possible coefficient vectors; over GF(256), there are \(256^K\). The space of possible equations is astronomically larger, making accidental linear dependence vanishingly rare.
	        </p>

	        <h3 class="text-xl font-bold text-white mt-16 mb-6">The Composition Trick</h3>
	        <p>
	            The overall overhead of a Raptor-style code is the product of its two layers. The precode adds a small constant expansion \(\delta\) (say, 3%), and the LT layer requires a small extra fraction \(\epsilon'\) (say, 2%) to get peeling "close enough." Combined:
	        </p>
	        <div class="text-center my-8 font-mono text-cyan-400 text-lg bg-white/5 py-4 rounded-xl border border-white/5">
	            \(K(1+\delta)(1+\epsilon') = K(1 + \delta + \epsilon' + \delta\epsilon') \approx K(1 + 0.05)\)
	        </div>
	        <p>
	            Both \(\delta\) and \(\epsilon'\) are <strong>constants independent of \(K\)</strong>. The \(\log K\) is gone. That's the asymptotic story: composition of a high-rate precode with a "good enough" fountain code yields a sharp-threshold rateless code with constant overhead and linear-time decoding.
	        </p>
	        <p>
	            And RaptorQ's engineering takes this further still. In practice, the dense HDPC core and permanent inactivations push the effective overhead down so far that +2 symbols is enough for one-in-a-million reliability at large \(K\). For \(K = 10{,}000\), that's <strong>0.02%</strong> overhead.
	        </p>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 6: A Brief History -->
	    <section class="editorial-container">
	        <h2 class="section-title">How We Got Here</h2>
	        <p>
	            RaptorQ isn't a single clever trick; it's the polished endpoint of a sequence of tricks that kept attacking the same tradeoff: <em>overhead vs. speed</em>.
	        </p>
	        <div class="mt-10 border-l border-white/10 pl-6 space-y-10">
	            <div>
	                <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-2">1998 · Digital Fountain</div>
	                <p class="text-slate-300 text-sm leading-relaxed mb-0">
	                    The original "fountain" metaphor: an endless spray of packets so receivers can join late, suffer loss, and still finish without feedback.
	                </p>
	            </div>
	            <div>
	                <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-2">2002 · LT Codes (Luby)</div>
	                <p class="text-slate-300 text-sm leading-relaxed mb-0">
	                    Sparse XOR equations + a tuned degree distribution so a peeling decoder can run fast. Revolutionary, but the last few symbols still force a non-constant tail overhead if you want vanishing failure probability.
	                </p>
	            </div>
	            <div>
	                <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-2">2006 · Raptor Codes (Shokrollahi)</div>
	                <p class="text-slate-300 text-sm leading-relaxed mb-0">
	                    The breakthrough: add a high-rate precode so the fountain layer only needs to get you "almost there". The log tail disappears; linear-time behavior becomes practical.
	                </p>
	            </div>
	            <div>
	                <div class="text-xs text-slate-500 uppercase tracking-widest font-bold mb-2">2011 · RaptorQ (RFC 6330)</div>
	                <p class="text-slate-300 text-sm leading-relaxed mb-0">
	                    Engineering refinements for real deployments: systematic encoding, deterministic symbol generation from an ID, inactivation decoding, and GF(256) insurance where rank matters.
	                </p>
	            </div>
	        </div>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 6.5: Shamir's Secret Sharing -->
	    <section class="editorial-container">
	        <h2 class="section-title">The Cryptographic Cousin</h2>
	        <p>
	            Before we compare RaptorQ to other erasure codes, it's worth taking a detour into cryptography—because the most illuminating parallel to fountain codes comes from an unexpected place.
	        </p>
	        <p>
	            In 1979, Adi Shamir (the "S" in RSA) published a scheme for splitting a secret into \(N\) pieces such that any \(K\) of them can reconstruct the secret, but \(K-1\) pieces reveal <em>absolutely nothing</em>. It's called <strong>Shamir's Secret Sharing</strong>, and if you squint, it's doing the same thing as a fountain code—with a very different goal in mind.
	        </p>

	        <div class="insight-card">
	            <h3 class="text-2xl font-bold text-white mb-6">A Concrete Example</h3>
	            <p class="text-slate-300 mb-4">
	                Suppose your secret is a number \(S = 42\) (the combination to a vault). You want to split it into 5 shares such that any 3 can reconstruct it, but 2 reveal nothing.
	            </p>
	            <p class="text-slate-300 mb-4">
	                Pick a random polynomial of degree \(K-1 = 2\), pinning the constant term to your secret:
	            </p>
	            <div class="bg-black/50 border border-white/5 rounded-2xl p-4 font-mono text-sm text-cyan-400 leading-relaxed mb-6">
	                \(f(x) = 42 + 7x + 3x^2\)
	            </div>
	            <p class="text-slate-300 mb-4">
	                Evaluate at 5 distinct points to create shares:
	            </p>
	            <div class="bg-black/50 border border-white/5 rounded-2xl p-4 font-mono text-sm text-slate-300 leading-relaxed mb-6 overflow-x-auto">
	                Share 1: \(f(1) = 42 + 7 + 3 = 52\)<br/>
	                Share 2: \(f(2) = 42 + 14 + 12 = 68\)<br/>
	                Share 3: \(f(3) = 42 + 21 + 27 = 90\)<br/>
	                Share 4: \(f(4) = 42 + 28 + 48 = 118\)<br/>
	                Share 5: \(f(5) = 42 + 35 + 75 = 152\)
	            </div>
	            <p class="text-slate-400 text-sm leading-relaxed mb-0">
	                To reconstruct the secret, any 3 people pool their shares and use <strong>Lagrange interpolation</strong> to recover the unique degree-2 polynomial passing through their 3 points. The secret is \(f(0) = 42\). It doesn't matter <em>which</em> 3 shares—any subset works.
	            </p>
	        </div>

	        <h3 class="text-xl font-bold text-white mt-16 mb-6">The Hidden Linear Algebra</h3>
	        <p>
	            Each share \((x_i, f(x_i))\) is secretly a linear equation in the unknown polynomial coefficients \([S, a_1, a_2]\):
	        </p>
	        <div class="bg-black/50 border border-white/5 rounded-2xl p-6 my-8 font-mono text-sm text-slate-300 leading-relaxed overflow-x-auto">
	            \(S + a_1 \cdot x_i + a_2 \cdot x_i^2 = f(x_i)\)
	        </div>
	        <p>
	            Three shares give you three equations in three unknowns. In matrix form, the coefficient matrix is a <strong>Vandermonde matrix</strong>—guaranteed to be full rank when the evaluation points \(x_i\) are distinct. So three shares always determine a unique polynomial, and hence a unique secret.
	        </p>
	        <p>
	            With only two shares, you have two equations and three unknowns. By the <strong>Rank-Nullity Theorem</strong>, the nullity is 1: the secret \(S\) can be <em>any</em> value consistent with those two equations. This is why \(K-1\) shares reveal zero information—it's not a heuristic claim, it's a mathematical proof. Every possible secret is equally compatible with any \(K-1\) shares.
	        </p>

	        <h3 class="text-xl font-bold text-white mt-16 mb-6">Same Continent, Different Countries</h3>
	        <p>
	            If you step back, both Shamir and RaptorQ are solving the same abstract problem with the same mathematical tools:
	        </p>
	        <ul class="list-disc list-inside space-y-3 text-slate-300 ml-4 mb-10 text-[1.05rem] leading-relaxed">
	            <li><strong>Linear algebra over finite fields.</strong> Both generate redundant linear measurements of unknown data.</li>
	            <li><strong>Redundancy through structure, not duplication.</strong> The polynomial (Shamir) or XOR constraint (RaptorQ) encodes relationships, not copies.</li>
	            <li><strong>Decoding as solving.</strong> Recovery means inverting a matrix—Vandermonde for Shamir, sparse + precode for RaptorQ.</li>
	            <li><strong>"Any \(K\) of \(N\)" from rank.</strong> The system is solvable precisely when you have \(K\) independent equations. Which equations is irrelevant.</li>
	        </ul>

	        <div class="overflow-x-auto my-12">
	            <table class="min-w-[700px] w-full text-sm text-slate-300 border border-white/10 rounded-2xl overflow-hidden">
	                <thead class="bg-white/5 text-slate-400 uppercase tracking-widest text-[10px]">
	                    <tr>
	                        <th class="text-left p-4">Property</th>
	                        <th class="text-left p-4">Shamir's Secret Sharing</th>
	                        <th class="text-left p-4">RaptorQ</th>
	                    </tr>
	                </thead>
	                <tbody class="divide-y divide-white/5">
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Threshold</td>
	                        <td class="p-4">Exact: \(K\) shares, always</td>
	                        <td class="p-4">Probabilistic: \(K + \epsilon\), almost always</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Matrix type</td>
	                        <td class="p-4">Dense Vandermonde (guaranteed rank)</td>
	                        <td class="p-4">Sparse + precode (rank with high probability)</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Security</td>
	                        <td class="p-4">\(K-1\) shares reveal nothing</td>
	                        <td class="p-4">No secrecy (matrix is public)</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Decode speed</td>
	                        <td class="p-4">\(O(K^2)\) (interpolation)</td>
	                        <td class="p-4">\(O(K)\) (peeling + small dense core)</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Coordination</td>
	                        <td class="p-4">Must know which shares you have</td>
	                        <td class="p-4">Self-identifying (ESI in each packet)</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Design goal</td>
	                        <td class="p-4">Certainty + secrecy</td>
	                        <td class="p-4">Speed + adaptivity</td>
	                    </tr>
	                </tbody>
	            </table>
	        </div>

	        <p>
	            Reed-Solomon codes—the technology behind PAR files, QR codes, CDs, and deep-space communication—complete the family tree. They're essentially Shamir's Secret Sharing applied to data recovery: evaluate a polynomial at many points, and any \(K\) evaluations recover the degree-\((K-1)\) polynomial via interpolation. Reed-Solomon is MDS-optimal but slow at scale and fixed-rate. Fountain codes sacrifice a sliver of that optimality (you need \(K+\epsilon\) instead of exactly \(K\)) in exchange for dramatic speedups and the rateless property.
	        </p>

	        <div class="callout">
	            If you understand Shamir's Secret Sharing, you're 80% of the way to understanding fountain codes. The leap from "secret sharing" to "erasure coding" is smaller than it appears—and the bridge is the Rank-Nullity Theorem.
	        </div>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 7: Comparisons -->
	    <section class="editorial-container">
	        <h2 class="section-title">RaptorQ vs. The Alternatives</h2>
	        <p>
	            The best way to appreciate RaptorQ is to see what it refuses to be.
	        </p>
	        <div class="overflow-x-auto my-12">
	            <table class="min-w-[700px] w-full text-sm text-slate-300 border border-white/10 rounded-2xl overflow-hidden">
	                <thead class="bg-white/5 text-slate-400 uppercase tracking-widest text-[10px]">
	                    <tr>
	                        <th class="text-left p-4">Scheme</th>
	                        <th class="text-left p-4">Overhead</th>
	                        <th class="text-left p-4">Speed</th>
	                        <th class="text-left p-4">Notes</th>
	                    </tr>
	                </thead>
	                <tbody class="divide-y divide-white/5">
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Reed-Solomon</td>
	                        <td class="p-4">0% (MDS)</td>
	                        <td class="p-4">Slower decode at large \(K\)</td>
	                        <td class="p-4">Great guarantees, fixed-rate, can become quadratic-ish in practice.</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Dense RLNC</td>
	                        <td class="p-4">Tiny</td>
	                        <td class="p-4">Too slow</td>
	                        <td class="p-4">Recovery like random matrices, but encoding touches many symbols; decoding is dense elimination.</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">Pure LT</td>
	                        <td class="p-4">\(O(\sqrt{K}\log^2 K)\) extra</td>
	                        <td class="p-4">Fast</td>
	                        <td class="p-4">Peeling-friendly; the best-known theory bounds still need growing extra symbols (and the tail is expensive) without a second stage.</td>
	                    </tr>
	                    <tr class="hover:bg-white/[0.02]">
	                        <td class="p-4 font-semibold text-white">RaptorQ</td>
	                        <td class="p-4">Tiny</td>
	                        <td class="p-4">Fast</td>
	                        <td class="p-4">Sparse almost everywhere; dense work quarantined to a small core; standardized for interoperability.</td>
	                    </tr>
	                </tbody>
	            </table>
	        </div>

	        <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	            <h4 class="text-white font-bold mb-4 text-xl">When RaptorQ Is The Right Tool</h4>
	            <ul class="list-disc list-inside space-y-2 text-slate-300 ml-2 text-sm leading-relaxed mb-0">
	                <li><strong>Broadcast/multicast:</strong> one sender, many receivers, each with different losses.</li>
	                <li><strong>High latency:</strong> retransmissions are expensive or impossible.</li>
	                <li><strong>Heterogeneous links:</strong> some receivers lose 2%, others lose 40%; the sender can't pick a single redundancy level.</li>
	                <li><strong>Anytime delivery:</strong> you want receivers to join mid-stream and still complete.</li>
	            </ul>
	        </div>

	        <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors mt-8">
	            <h4 class="text-white font-bold mb-4 text-xl">Glossary (The Variables You Keep Seeing)</h4>
	            <ul class="list-disc list-inside space-y-2 text-slate-300 ml-2 text-sm leading-relaxed mb-0">
	                <li><strong>\(T\):</strong> symbol size (bytes per symbol); you split the file into \(K\) symbols of \(T\) bytes.</li>
	                <li><strong>\(K\):</strong> number of source symbols (the thing you conceptually want back).</li>
	                <li><strong>\(K'\):</strong> the padded/extended source block size used internally by RFC 6330 (very close to \(K\)).</li>
	                <li><strong>\(L\):</strong> number of intermediate symbols after precoding (the thing the decoder actually solves for).</li>
	                <li><strong>\(y\):</strong> an encoding symbol (a received packet payload), i.e. one linear equation.</li>
	                <li><strong>\(d\):</strong> degree of a packet (how many symbols it touches).</li>
	                <li><strong>ISI/ESI:</strong> the integer ID that lets the receiver reconstruct the equation for a repair packet.</li>
	                <li><strong>Ripple / 2-core:</strong> the set of degree-1 checks, and the residual stuck core when none exist.</li>
	            </ul>
	        </div>

	        <div class="insight-card !my-0 !p-8 !bg-slate-900/50 hover:bg-slate-900 transition-colors mt-8">
	            <h4 class="text-white font-bold mb-4 text-xl">Integrity (RaptorQ Is Not Crypto)</h4>
	            <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                RaptorQ is designed for random erasures, not adversaries. A single corrupted packet can poison the decoded output.
	                In real systems you typically pair it with an object hash (and often a signature), and sometimes packet authentication (e.g., TESLA-style schemes) so receivers can discard bad packets early.
	            </p>
	        </div>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 8: The Math Underpinnings -->
	    <section class="editorial-container">
	        <h2 class="section-title">The Deep Math</h2>
		        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">The Rank-Nullity Theorem</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    The governing law of fountain decoding is: \(\mathrm{rank}(A) + \mathrm{nullity}(A) = K\), where \(K\) is the number of unknown source symbols.<br/><br/>
		                    Every linearly independent packet you receive increases rank by 1 and reduces nullity by 1. When nullity reaches 0, the solution is unique. RaptorQ is an efficient way to drive nullity to 0 without doing a full \(O(K^3)\) dense solve.
		                </p>
		            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Triangular Systems &amp; LU Decomposition</h4>
	                <p class="text-sm text-slate-400 leading-relaxed">
	                    The peeling process, when it succeeds, produces a <strong>lower triangular matrix</strong> (after reordering rows and columns). Triangular matrices are always full rank, and solving them is \(O(K)\) by back-substitution—no Gaussian elimination needed. This is why peeling is so fast: it's essentially discovering an <strong>LU decomposition</strong> via graph operations, exploiting sparsity. Each peeling step identifies a pivot (a degree-1 check) and eliminates the corresponding variable, building up the triangular structure one row at a time.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">The Schur Complement</h4>
	                <p class="text-sm text-slate-400 leading-relaxed">
	                    When peeling stalls, inactivation decoding partitions the remaining matrix into blocks. The "active" part \(A\) is eliminated cheaply via peeling. The coupling blocks \(B\) and \(C\) connect it to the small "inactivated core" \(D\). The dense core is then solved via its <strong>Schur complement</strong>: \(D - C \cdot A^{-1} \cdot B\). If the core has \(p\) symbols out of \(L\) total, the dense solve costs \(O(p^3)\) instead of \(O(L^3)\)—and RaptorQ ensures \(p \ll L\). This classical numerical linear algebra technique is the exact reason inactivation keeps overall decoding near-linear.
	                </p>
	            </div>
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">Finite Fields: GF(256)</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    Most sparse codes fail because of "unlucky" dependencies (rank deficiency). RaptorQ mitigates this by doing its dense insurance work (the HDPC precode) in <strong>GF(256)</strong> rather than GF(2).<br/><br/>
		                    For a random \(K \times K\) matrix over GF(\(q\)): \(P(\text{full rank}) = \prod_{j=1}^{K} (1 - q^{-j})\). Over GF(2), this tends to about <strong>0.288</strong> (so ~71% singular). Over GF(256), it tends to about <strong>0.996</strong> (so ~0.4% singular), and every extra independent equation tends to crush failure by a factor of ~\(1/256\).
		                </p>
		            </div>
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">Stopping Sets (The 2-Core)</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    The peeling decoder fails when the residual bipartite graph has no degree-1 checks. This residual subgraph is the <strong>2-core</strong>: every remaining check node has degree \(\ge 2\), so no equation directly reveals a variable.
		                    RaptorQ's whole architecture is built to keep this core small, then solve it with inactivation + the precode's extra constraints.
		                </p>
		            </div>
		            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
		                <h4 class="text-white font-bold mb-4 text-xl">Spectral Theory (Where It Actually Helps)</h4>
		                <p class="text-sm text-slate-400 leading-relaxed">
		                    You don't compute eigenvalues to decode RaptorQ. But spectral/expander intuition <em>does</em> show up in the design and analysis of LDPC-style precodes: good expansion means information propagates quickly across the constraint graph, so a small missing set can be inferred from the rest.
		                </p>
		            </div>
		        </div>
		    </section>

	    <div class="section-divider"></div>

	    <!-- Section 9: Where RaptorQ Lives -->
	    <section class="editorial-container pb-16">
	        <h2 class="section-title">Where RaptorQ Lives</h2>
	        <p>
	            RaptorQ's properties—fungible symbols, near-zero overhead, linear-time encoding/decoding, ratelessness—don't just make for elegant theory. They fundamentally change the economics of data distribution in the real world.
	        </p>
	        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-12">
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Broadcast &amp; Multicast</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-2">
	                    A satellite broadcasting a firmware update to a million devices doesn't track which devices are missing which packets. It broadcasts a stream of encoding symbols. Each device tunes in whenever it can, collects symbols until it has enough, and reconstructs the file. Late joiners aren't penalized. High-loss devices just take longer.
	                </p>
	                <p class="text-xs text-slate-500 mb-0">
	                    <strong>3GPP MBMS</strong> mandates Raptor for multimedia broadcast/multicast services. <strong>ATSC 3.0</strong> (next-gen digital TV) uses RaptorQ for over-the-air file delivery.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Object Delivery (ROUTE/FLUTE)</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-2">
	                    The ROUTE and FLUTE protocols use RaptorQ as their forward error correction layer for delivering large objects over unidirectional IP multicast. A CDN edge node sprays encoded symbols; each client independently reconstructs what it needs.
	                </p>
	                <p class="text-xs text-slate-500 mb-0">
	                    RaptorQ is the FEC scheme specified under <strong>FEC Encoding ID 6</strong> in the IETF's FECFRAME architecture.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Distributed Storage</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    If you're distributing a file across a storage network (IPFS, BitTorrent, CDN edge nodes), each node can store <em>different</em> encoding symbols. Any subset of nodes holding collectively \(K\) symbols can serve the complete file. No coordination about <em>which</em> symbols each node stores—they're all equally valuable.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-slate-900/50 hover:bg-slate-900 transition-colors">
	                <h4 class="text-white font-bold mb-4 text-xl">Hybrid ARQ &amp; Deep Space</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    In wireless and satellite communication, Hybrid ARQ schemes send initial data and, if that's not enough, send additional repair symbols. With RaptorQ, the repair symbols don't need to be chosen based on what was lost—any new symbols will do. This eliminates per-loss feedback and simplifies the protocol enormously. When your round-trip time is 40 minutes (Mars) or 4 hours (Jupiter), that simplification is existential.
	                </p>
	            </div>
	        </div>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Section 10: RaptorQ in the Wild -->
	    <section class="editorial-container">
	        <h2 class="section-title">RaptorQ in the Wild</h2>
	        <p>
	            The mathematics above isn't academic. RaptorQ is deployed at scale in systems serving billions of devices—and increasingly, in projects that treat fountain codes not as a networking curiosity but as a foundational primitive.
	        </p>

	        <!-- 3G/4G/5G Cellular -->
	        <h3 class="text-3xl font-bold text-white mt-16 mb-6">The Cellular Standard</h3>
	        <p>
	            In 2005, the 3GPP consortium faced a problem: delivering video, firmware updates, and emergency alerts to millions of handsets simultaneously over cellular. Traditional unicast—one connection per device—doesn't scale. You can't open a million TCP sessions from a single cell tower. The answer was <strong>MBMS</strong> (Multimedia Broadcast/Multicast Service), and MBMS needed an FEC layer that could handle massive fan-out over a lossy wireless channel with zero back-channel.
	        </p>
	        <p>
	            They chose Raptor codes—later upgraded to RaptorQ. The specification is <strong>3GPP TS 26.346</strong>, and it makes RaptorQ the mandatory FEC scheme for file delivery and streaming. Every compliant LTE and 5G modem on Earth implements it.
	        </p>

	        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-10 mb-12">
	            <div class="insight-card !my-0 !bg-gradient-to-b from-blue-950/40 to-slate-900/40 border border-blue-500/10">
	                <h4 class="text-blue-400 font-bold mb-3 text-lg">3G/4G: MBMS &amp; eMBMS</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    The original MBMS spec and its evolved form (eMBMS) use RaptorQ for one-to-many file delivery. A cell tower broadcasts encoded symbols; handsets tune in, collect enough, and decode. No ACKs, no per-device state. KT Korea deployed this during the 2018 PyeongChang Olympics to stream 4K video to stadiums full of phones. Verizon's go90 service used eMBMS to push live video without saturating unicast capacity.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-gradient-to-b from-purple-950/40 to-slate-900/40 border border-purple-500/10">
	                <h4 class="text-purple-400 font-bold mb-3 text-lg">5G Broadcast (5G-BC)</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    5G NR continues the tradition. 3GPP Release 16+ defines 5G Broadcast with RaptorQ as the application-layer FEC. The use cases have expanded: connected car firmware updates (BMW and Audi have tested eMBMS for over-the-air updates), IoT fleet provisioning, and emergency alert distribution. A single broadcast stream can push a critical patch to every vehicle in a city simultaneously.
	                </p>
	            </div>
	            <div class="insight-card !my-0 !bg-gradient-to-b from-cyan-950/40 to-slate-900/40 border border-cyan-500/10">
	                <h4 class="text-cyan-400 font-bold mb-3 text-lg">ATSC 3.0 (NextGen TV)</h4>
	                <p class="text-sm text-slate-400 leading-relaxed mb-0">
	                    The next-generation digital television standard adopted RaptorQ for over-the-air file delivery via the ROUTE protocol. Real deployments include WHUT-TV datacasting in Washington, D.C. and New Mexico PBS distributing emergency alert data. The key insight: a TV transmitter is the ultimate one-to-many channel, and RaptorQ turns it into an efficient file delivery system.
	                </p>
	            </div>
	        </div>

	        <div class="insight-card !bg-slate-800/30 border border-slate-700/30">
	            <p class="text-slate-300 text-sm mb-0">
	                <strong class="text-white">The common thread:</strong> Every deployment above exploits the same property. The sender doesn't know (or care) how many receivers exist, which symbols each receiver has, or when each receiver started listening. It just sprays symbols. Each receiver independently collects and decodes. This is the "coordination-free" property from the math—\(K\) distinct evaluations of a degree \(K{-}1\) polynomial determine it uniquely, regardless of <em>which</em> evaluations you have.
	            </p>
	        </div>

	        <!-- Author's Projects -->
	        <h3 class="text-3xl font-bold text-white mt-20 mb-4">Beyond Networking: Fountain Codes as a Systems Primitive</h3>
	        <p>
	            The deployments above use RaptorQ the way its inventors intended—as a network transport layer. But what happens when you treat fountain codes not as a wire protocol but as a <em>foundational abstraction</em> for building systems? Three projects by the author of this article explore that question.
	        </p>

	        <!-- AsuperSync -->
	        <div class="insight-card !bg-gradient-to-br from-emerald-950/30 via-slate-900/40 to-slate-900/40 border border-emerald-500/15 mt-12">
	            <div class="flex items-center gap-3 mb-4">
	                <span class="text-xs font-mono uppercase tracking-widest text-emerald-400/70 bg-emerald-400/10 px-2.5 py-1 rounded">Rust Library</span>
	                <a href="https://github.com/Dicklesworthstone/asupersync" target="_blank" class="text-emerald-400 hover:text-emerald-300 text-sm font-mono transition-colors">asupersync &rarr;</a>
	            </div>
	            <h4 class="text-white font-bold text-xl mb-3">A Ground-Up RFC 6330 Implementation for Distributed Runtimes</h4>
	            <p class="text-slate-300 leading-relaxed mb-4">
	                Asupersync is a spec-first async runtime for Rust with a complete, from-scratch RaptorQ implementation. The <code class="text-emerald-400/80">src/raptorq/</code> module spans 10 files: GF(256) arithmetic with precomputed 64KB multiplication tables, systematic encoding with LDPC/HDPC/LT constraint matrices, a two-phase inactivation decoder (peeling first, then Gaussian elimination over the dense core), and deterministic decode proofs for auditable recovery.
	            </p>
	            <p class="text-slate-400 text-sm leading-relaxed mb-4">
	                The key application: <strong>distributed state recovery</strong>. When a runtime "region" (the structured concurrency unit) needs to persist its state across a cluster, it doesn't fully replicate to every node. Instead, the region snapshot is erasure-coded into symbols and distributed via consistent hashing. Recovery requires collecting any \(K\) symbols from surviving nodes—it doesn't matter which \(K\). Storage overhead drops from \(N{\times}\) full replication to roughly \(1.2{\times}\), while fault tolerance <em>increases</em>.
	            </p>
	            <div class="grid grid-cols-2 gap-4">
	                <div class="text-xs text-slate-500 bg-slate-800/30 rounded-lg p-3">
	                    <span class="text-emerald-400/70 font-bold">Encoding</span><br>
	                    Systematic RaptorQ with configurable repair overhead (default 20%). Source symbols are the original data; repair symbols are GF(256) linear combinations.
	                </div>
	                <div class="text-xs text-slate-500 bg-slate-800/30 rounded-lg p-3">
	                    <span class="text-emerald-400/70 font-bold">Distribution</span><br>
	                    Consistent hash ring maps symbols to replicas. Quorum semantics (One, Quorum, All) control durability/latency tradeoffs.
	                </div>
	            </div>
	        </div>

	        <!-- FrankenSQLite -->
	        <div class="insight-card !bg-gradient-to-br from-amber-950/30 via-slate-900/40 to-slate-900/40 border border-amber-500/15 mt-8">
	            <div class="flex items-center gap-3 mb-4">
	                <span class="text-xs font-mono uppercase tracking-widest text-amber-400/70 bg-amber-400/10 px-2.5 py-1 rounded">Rust &middot; 23-Crate Workspace</span>
	                <a href="https://github.com/Dicklesworthstone/frankensqlite" target="_blank" class="text-amber-400 hover:text-amber-300 text-sm font-mono transition-colors">frankensqlite &rarr;</a>
	            </div>
	            <h4 class="text-white font-bold text-xl mb-3">A Self-Healing SQLite with Fountain Codes at Every Layer</h4>
	            <p class="text-slate-300 leading-relaxed mb-4">
	                FrankenSQLite is a ground-up Rust reimplementation of SQLite that embeds RaptorQ into every persistent layer. The premise: data corruption shouldn't be a failure mode you <em>mitigate</em>—it should be a mathematical near-impossibility. Standard SQLite WAL recovery truncates at the first corrupted frame, discarding all subsequent committed data. FrankenSQLite instead generates repair symbols for each commit group and stores them in a <code class="text-amber-400/80">.wal-fec</code> sidecar.
	            </p>
	            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
	                <div class="bg-slate-800/30 rounded-lg p-4">
	                    <h5 class="text-amber-400/80 font-bold text-sm mb-2">WAL Self-Healing</h5>
	                    <p class="text-xs text-slate-400 leading-relaxed mb-0">
	                        Each committed transaction's pages become \(K\) source symbols. \(R\) repair symbols (default \(R{=}2\)) are generated asynchronously and stored in the sidecar. On recovery, corrupted frames are identified by per-page XXH3-128 checksums; valid source + repair symbols feed the decoder. Failure probability at \(K{+}2\): approximately \(10^{-7}\).
	                    </p>
	                </div>
	                <div class="bg-slate-800/30 rounded-lg p-4">
	                    <h5 class="text-amber-400/80 font-bold text-sm mb-2">Database-Level FEC</h5>
	                    <p class="text-xs text-slate-400 leading-relaxed mb-0">
	                        A separate <code class="text-amber-400/60">.db-fec</code> sidecar protects the main database file. Page 1 (the header) gets 400% redundancy. Remaining pages are grouped in 64-page chunks with 6.25% overhead. Corrupted pages are reconstructed on read—transparently, without user intervention.
	                    </p>
	                </div>
	                <div class="bg-slate-800/30 rounded-lg p-4">
	                    <h5 class="text-amber-400/80 font-bold text-sm mb-2">Fountain-Coded Snapshots</h5>
	                    <p class="text-xs text-slate-400 leading-relaxed mb-0">
	                        Full database transfers use RaptorQ's rateless property. The database is partitioned into source blocks respecting RFC 6330's \(K_{\max}{=}56{,}403\) limit and streamed as a continuous fountain over UDP. Receivers start at any point, resume after disconnection without renegotiation, and a single sender stream serves \(N\) receivers simultaneously.
	                    </p>
	                </div>
	                <div class="bg-slate-800/30 rounded-lg p-4">
	                    <h5 class="text-amber-400/80 font-bold text-sm mb-2">Durability Guarantees</h5>
	                    <p class="text-xs text-slate-400 leading-relaxed mb-0">
	                        For \(K\) source symbols with \(R\) repair symbols and independent per-symbol corruption probability \(p{=}10^{-4}\): the probability of data loss drops below \(10^{-5K}\). For a 1,000-page database, that's below \(10^{-5000}\)—a number that transcends "nines of availability" entirely.
	                    </p>
	                </div>
	            </div>
	        </div>

	        <!-- Flywheel Connectors -->
	        <div class="insight-card !bg-gradient-to-br from-sky-950/30 via-slate-900/40 to-slate-900/40 border border-sky-500/15 mt-8">
	            <div class="flex items-center gap-3 mb-4">
	                <span class="text-xs font-mono uppercase tracking-widest text-sky-400/70 bg-sky-400/10 px-2.5 py-1 rounded">Mesh Protocol</span>
	                <a href="https://github.com/Dicklesworthstone/flywheel_connectors" target="_blank" class="text-sky-400 hover:text-sky-300 text-sm font-mono transition-colors">flywheel_connectors &rarr;</a>
	            </div>
	            <h4 class="text-white font-bold text-xl mb-3">A Symbol-First Mesh Protocol for AI Agent Networks</h4>
	            <p class="text-slate-300 leading-relaxed mb-4">
	                The Flywheel Connector Protocol (FCP) takes the fountain code idea to its logical extreme: <strong>there are no files on the wire, only symbols</strong>. Data is encoded into RaptorQ symbols before it ever leaves a device. The symbols are distributed across a Tailscale mesh, encrypted per-zone with capability-based access control. Reconstruction happens lazily, at the receiver, when enough symbols accumulate.
	            </p>
	            <p class="text-slate-400 text-sm leading-relaxed mb-4">
	                This "symbol-first" architecture exploits three RaptorQ properties simultaneously: <strong>multipath aggregation</strong> (symbols arriving from different network paths contribute equally—no retransmission coordination), <strong>offline resilience</strong> (partial symbol availability enables partial reconstruction; data availability becomes probabilistic rather than binary), and <strong>diffuse failure</strong> (no single symbol is critical, so attackers can't target "important" chunks). Each FCPS frame carries a 114-byte header with object ID, zone key ID, epoch, and sender identity—making every symbol self-describing and independently useful.
	            </p>
	        </div>

	        <div class="insight-card !bg-slate-800/30 border border-slate-700/30 mt-10">
	            <p class="text-slate-300 text-sm mb-0">
	                <strong class="text-white">The pattern across all three projects:</strong> RaptorQ stops being a "network layer" and becomes an <em>information substrate</em>. In FrankenSQLite, every page on disk is fountain-coded. In asupersync, every runtime state checkpoint is fountain-coded. In Flywheel Connectors, every object in transit is fountain-coded. The "any \(K\) of \(N\)" property isn't just for surviving packet loss—it's for building systems where data integrity is a mathematical invariant, not a best-effort aspiration.
	            </p>
	        </div>
	    </section>

	    <div class="section-divider"></div>

	    <!-- Closing Insight -->
	    <section class="editorial-container pb-32">
	        <p class="text-3xl font-bold text-center text-white my-16 leading-tight max-w-3xl mx-auto">
	            The right mathematical abstraction transforms an apparently intractable problem into a natural one.
	        </p>
	        <p>
	            The trick wasn't any single clever hack. It was recognizing that erasure coding is secretly linear algebra, that linear algebra over finite fields gives you fungibility for free, that the hard part is making the matrix sparse enough to solve fast, and that the solution is a divide-and-conquer strategy: handle the easy 97% with a graph algorithm and the hard 3% with a small amount of dense algebra.
	        </p>
	        <p>
	            The fact that this entire edifice—ratelessness, fungibility, near-optimal overhead, linear-time decoding—falls out of combining a sparse fountain layer with a dense inner code is one of the most beautiful results in applied mathematics. It's the kind of thing that makes you want to look at every other seemingly-fundamental tradeoff and ask: is there a Raptor-like decomposition hiding here too?
	        </p>
	    </section>

    <!-- Footer -->
    <footer class="border-t border-white/10 py-24 bg-[#020203]">
        <div class="editorial-container text-center">
            <h2 class="text-4xl font-bold text-white mb-8">Built for the Infinite.</h2>
            <p class="text-slate-500 mb-12 max-w-lg mx-auto">
                RaptorQ sits at the intersection of Linear Algebra, Graph Theory, and practical Engineering. It powers the 3GPP MBMS standard, ATSC 3.0, and ROUTE/FLUTE-style multicast delivery.
            </p>
            <div class="flex flex-wrap justify-center gap-x-8 gap-y-3 text-sm font-mono uppercase tracking-widest">
                 <a href="https://datatracker.ietf.org/doc/html/rfc6330" target="_blank" class="text-slate-600 hover:text-cyan-400 transition-colors">RFC 6330</a>
                 <a href="https://doi.org/10.1109/SFCS.2002.1181950" target="_blank" class="text-slate-600 hover:text-cyan-400 transition-colors">LT Codes (2002)</a>
                 <a href="https://doi.org/10.1109/TIT.2006.874390" target="_blank" class="text-slate-600 hover:text-cyan-400 transition-colors">Raptor Codes (2006)</a>
                 <a href="https://web.mit.edu/6.857/OldStuff/Fall03/ref/Shamir-HowToShareASecret.pdf" target="_blank" class="text-slate-600 hover:text-cyan-400 transition-colors">Shamir (1979)</a>
                 <a href="raptorq_article_research.md" class="text-slate-600 hover:text-cyan-400 transition-colors">Research Notes</a>
                 <a href="01_xor_encoding_decoding.py" class="text-slate-600 hover:text-cyan-400 transition-colors">XOR Demo</a>
                 <a href="02_lt_code_simulation.py" class="text-slate-600 hover:text-cyan-400 transition-colors">LT Demo</a>
                 <a href="03_raptorq_precoding.py" class="text-slate-600 hover:text-cyan-400 transition-colors">Precode Demo</a>
            </div>
        </div>
    </footer>

    <!-- Logic -->
    <script src="visualizations.js"></script>
    <script>
        // Progress Bar (rAF throttled + transform: avoids layout on every scroll)
        (() => {
            const bar = document.getElementById('progress-bar');
            if (!bar) return;

            let ticking = false;
            let lastScrollY = 0;

            const update = () => {
                ticking = false;

                const doc = document.documentElement;
                const height = Math.max(1, doc.scrollHeight - doc.clientHeight);
                const ratio = Math.max(0, Math.min(1, lastScrollY / height));

                bar.style.transform = `scaleX(${ratio})`;
            };

            const onScroll = () => {
                lastScrollY = window.scrollY || document.documentElement.scrollTop || 0;
                if (!ticking) {
                    ticking = true;
                    requestAnimationFrame(update);
                }
            };

            window.addEventListener('scroll', onScroll, { passive: true });
            onScroll();
        })();

        // Initialize animations on load
        window.addEventListener('load', () => {
            if(window.initHero) window.initHero();
            if(window.matrixViz) window.matrixViz.init();
            if(window.degreeRippleViz) window.degreeRippleViz.init();
            if(window.precodeViz) window.precodeViz.init();
            if(window.toyDecodeViz) window.toyDecodeViz.init();
            if(window.peelingViz) window.peelingViz.init();
        });
    </script>
</body>
</html>
